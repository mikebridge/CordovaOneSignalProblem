{"version":3,"file":"parse-ndef-message.js","sourceRoot":"","sources":["../../src/www/tap-ndef/parse-ndef-message.ts"],"names":[],"mappings":";;AACA,oFAAkF;AAMlF,SAAgB,mBAAmB,CAAC,QAAsB;IACtD,IAAI,MAAM,GAAqB,EAAE,CAAC;IAClC,IAAI,QAAQ,CAAC,MAAM,IAAI,CAAC,EAAE;QACtB,IAAI,QAAQ,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC;QACnC,MAAM,CAAC,GAAG,GAAG,aAAa,CAAC,QAAQ,CAAC,CAAC;KACxC;IACD,IAAI,QAAQ,CAAC,MAAM,IAAI,CAAC,EAAE;QACtB,MAAM,CAAC,GAAG,GAAG,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;KACnD;IACD,IAAI,QAAQ,CAAC,MAAM,IAAI,CAAC,EAAE;QACtB,IAAI,QAAQ,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC;QACnC,IAAI,IAAI,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;QACvB,IAAI,OAAO,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QAChC,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;QAEnB,QAAQ,IAAI,EAAE;YACV,KAAK,mBAAmB,CAAC,GAAG;gBACxB,MAAM,CAAC,UAAU,GAAG,wBAAwB,CAAC,OAAO,CAAC,CAAC;gBACtD,MAAM;YACV,KAAK,mBAAmB,CAAC,IAAI;gBACzB,MAAM,CAAC,IAAI,GAAG,aAAa,CAAC,OAAO,CAAC,CAAC;gBACrC,MAAM;SACb;KACJ;IACD,IAAI,QAAQ,CAAC,MAAM,IAAI,CAAC,EAAE;QACtB,MAAM,CAAC,IAAI,GAAG,aAAa,CAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;KACrD;IACD,OAAO,MAAM,CAAC;AAClB,CAAC;AA5BD,kDA4BC;AAED,IAAK,mBAGJ;AAHD,WAAK,mBAAmB;IACpB,8DAAW,CAAA;IACX,4DAAU,CAAA;AACd,CAAC,EAHI,mBAAmB,KAAnB,mBAAmB,QAGvB;AAED,SAAS,aAAa,CAAC,OAAiB;IACpC,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,IAAI,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,EAAC;QACvC,OAAO,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;KAC9B;IACD,OAAO,4BAAY,CAAC,aAAa,CAAC,OAA4B,CAAC,CAAC;AACpE,CAAC;AAED,SAAS,wBAAwB,CAAC,KAAe;IAC7C,OAAO,KAAK,CAAC,GAAG,CAAC,UAAA,IAAI;QACjB,IAAI,IAAI,GAAG,CAAC,EAAE;YACV,IAAI,IAAI,GAAG,CAAC;SACf;QACD,IAAI,UAAU,GAAG,GAAG,GAAG,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,WAAW,EAAE,CAAC;QACvD,UAAU,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;QAClC,OAAO,UAAU,CAAC;IACtB,CAAC,CAAC;SACG,OAAO,EAAE;SACT,IAAI,CAAC,GAAG,CAAC,CAAA;AAClB,CAAC","sourcesContent":["import { TapNfcTagPayload, NdefRecord } from \"./definitions\";\r\nimport { FormatHelper } from \"@iotize/device-client.js/core/format/format-helper\";\r\n\r\n/**\r\n * We manage only on NDEF message with 3 records:\r\n * record 0 = URI; record 1 = AAR; record 2 = BLE MAC ADDRESS / BSSID; record 3: universal link\r\n */\r\nexport function parseTapNdefMessage(messages: NdefRecord[]): TapNfcTagPayload {\r\n    let result: TapNfcTagPayload = {};\r\n    if (messages.length >= 1) {\r\n        let asciiUri = messages[0].payload;\r\n        result.uri = toAsciiString(asciiUri);\r\n    }\r\n    if (messages.length >= 2) {\r\n        result.aar = toAsciiString(messages[1].payload);\r\n    }\r\n    if (messages.length >= 3) {\r\n        let payload3 = messages[2].payload;\r\n        let type = payload3[0];\r\n        let content = payload3.slice(1);\r\n        result.type = type;\r\n\r\n        switch (type) {\r\n            case TapNdefProtocolType.BLE:\r\n                result.macAddress = convertBytesToBLEAddress(content);\r\n                break;\r\n            case TapNdefProtocolType.WiFi:\r\n                result.ssid = toAsciiString(content);\r\n                break;\r\n        }\r\n    }\r\n    if (messages.length >= 4) {\r\n        result.name = toAsciiString( messages[3].payload);\r\n    }\r\n    return result;\r\n}\r\n\r\nenum TapNdefProtocolType {\r\n    WiFi = 0x20,\r\n    BLE = 0x40\r\n}\r\n\r\nfunction toAsciiString(payload: number[]): string {\r\n    if (payload.length > 0 && payload[0] === 0){\r\n        payload = payload.slice(1);\r\n    }\r\n    return FormatHelper.toAsciiString(payload as any as Uint8Array);\r\n}\r\n\r\nfunction convertBytesToBLEAddress(bytes: number[]): string {\r\n    return bytes.map(byte => {\r\n        if (byte < 0) {\r\n            byte += 256;\r\n        }\r\n        let byteString = '0' + byte.toString(16).toUpperCase();\r\n        byteString = byteString.slice(-2);\r\n        return byteString;\r\n    })\r\n        .reverse()\r\n        .join(':')\r\n}"]}